<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java基础语法</title>
      <link href="/2023/01/17/java/Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
      <url>/2023/01/17/java/Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="1-3-Java基础语法"><a href="#1-3-Java基础语法" class="headerlink" title="1.3 Java基础语法"></a>1.3 Java基础语法</h3><h4 id="1-1-基础数据类型"><a href="#1-1-基础数据类型" class="headerlink" title="1.1 基础数据类型"></a>1.1 基础数据类型</h4><ul><li>整型 int  byte short int long </li><li>浮点 类型float 单精度  double 双精度</li><li>char 字符型</li><li>布尔类型boolean</li></ul><h4 id="1-2-命名规范"><a href="#1-2-命名规范" class="headerlink" title="1.2 命名规范"></a>1.2 命名规范</h4><p>编写 Java 程序时，应注意以下几点：</p><ul><li><strong>大小写敏感</strong>：Java 是大小写敏感的，这就意味着标识符 Hello 与 hello 是不同的。</li><li><strong>类名</strong>：对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如 <strong>MyFirstJavaClass</strong> 。</li><li><strong>方法名</strong>：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写。</li><li><strong>源文件名</strong>：源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记 Java 是大小写敏感的），文件名的后缀为 <strong>.java</strong>。（如果文件名和类名不相同则会导致编译错误）。</li></ul><h4 id="1-3Java-标识符"><a href="#1-3Java-标识符" class="headerlink" title="1.3Java 标识符"></a>1.3Java 标识符</h4><p>Java 所有的组成部分都需要名字。类名、变量名以及方法名都被称为标识符。</p><p>关于 Java 标识符，有以下几点需要注意：</p><ul><li>所有的标识符都应该以字母（A-Z 或者 a-z）,美元符（$）、或者下划线（_）开始</li><li>首字符之后可以是字母（A-Z 或者 a-z）,美元符（$）、下划线（_）或数字的任何字符组合</li><li>关键字不能用作标识符</li><li>标识符是大小写敏感的</li><li>合法标识符举例：age、$salary、_value、__1_value</li><li>非法标识符举例：123abc、-salary</li></ul><h4 id="1-4Java修饰符"><a href="#1-4Java修饰符" class="headerlink" title="1.4Java修饰符"></a>1.4Java修饰符</h4><ul><li>像其他语言一样，Java可以使用修饰符来修饰类中方法和属性。主要有两类修饰符：</li><li>访问控制修饰符 : default, public , protected, private</li><li>非访问控制修饰符 : final, abstract, static, synchronized</li></ul><h4 id="1-5Java-变量Java-中几种类型的变量"><a href="#1-5Java-变量Java-中几种类型的变量" class="headerlink" title="1.5Java 变量Java 中几种类型的变量"></a>1.5Java 变量Java 中几种类型的变量</h4><ul><li>局部变量</li><li>类变量（静态变量）</li><li>成员变量（非静态变量）</li></ul><h4 id="1-6-if-语句的语法如下："><a href="#1-6-if-语句的语法如下：" class="headerlink" title="1.6 if 语句的语法如下："></a>1.6 if 语句的语法如下：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//如果布尔表达式为true将执行的语句</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">      <span class="keyword">if</span>( x &lt; <span class="number">20</span> )&#123;</span><br><span class="line">         System.out.print(<span class="string">&quot;这是 if 语句&quot;</span>);</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;0000000&quot;</span>)      </span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-7switch语句"><a href="#1-7switch语句" class="headerlink" title="1.7switch语句"></a>1.7switch语句</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(expression)&#123;</span><br><span class="line">    <span class="keyword">case</span> value :语句  <span class="keyword">break</span>; <span class="comment">//可选</span></span><br><span class="line">    <span class="keyword">case</span> value :语句<span class="keyword">break</span>; <span class="comment">//可选</span></span><br><span class="line">    <span class="keyword">default</span> : <span class="comment">//可选</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">      <span class="comment">//char grade = args[0].charAt(0);</span></span><br><span class="line"></span><br><span class="line">      <span class="type">char</span> <span class="variable">grade</span> <span class="operator">=</span> <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">switch</span>(grade)</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span> :</span><br><span class="line">            System.out.println(<span class="string">&quot;优秀&quot;</span>); </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span> :</span><br><span class="line">         <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span> :</span><br><span class="line">            System.out.println(<span class="string">&quot;良好&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span> :</span><br><span class="line">            System.out.println(<span class="string">&quot;及格&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="string">&#x27;F&#x27;</span> :</span><br><span class="line">            System.out.println(<span class="string">&quot;你需要再努力努力&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">default</span> :</span><br><span class="line">            System.out.println(<span class="string">&quot;未知等级&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">&quot;你的等级是 &quot;</span> + grade);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-8-while"><a href="#1-8-while" class="headerlink" title="1.8 while"></a>1.8 while</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>( 布尔表达式 ) &#123;</span><br><span class="line">  <span class="comment">//循环内容</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">      <span class="keyword">while</span>( x &lt; <span class="number">20</span> ) &#123;</span><br><span class="line">         System.out.print(<span class="string">&quot;value of x : &quot;</span> + x );</span><br><span class="line">         x++;</span><br><span class="line">         System.out.print(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-9-for循环"><a href="#1-9-for循环" class="headerlink" title="1.9 for循环"></a>1.9 for循环</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">or(初始化; 布尔表达式; 更新) &#123;</span><br><span class="line">    <span class="comment">//代码语句</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-0-break-关键字"><a href="#2-0-break-关键字" class="headerlink" title="2.0 break 关键字"></a>2.0 break 关键字</h4><p>​break 主要用在循环语句或者 switch 语句中，用来跳出整个语句块。</p><p>break 跳出最里层的循环，并且继续执行该循环下面的语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">int</span> [] numbers = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> x : numbers ) &#123;</span><br><span class="line">         <span class="comment">// x 等于 30 时跳出循环</span></span><br><span class="line">         <span class="keyword">if</span>( x == <span class="number">30</span> ) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         System.out.print( x );</span><br><span class="line">         System.out.print(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-1-continue"><a href="#2-1-continue" class="headerlink" title="2.1 continue"></a>2.1 continue</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">int</span> [] numbers = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> x : numbers ) &#123;</span><br><span class="line">         <span class="keyword">if</span>( x == <span class="number">30</span> ) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         System.out.print( x );</span><br><span class="line">         System.out.print(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java io流</title>
      <link href="/2023/01/17/java/java%20io%E6%B5%81/"/>
      <url>/2023/01/17/java/java%20io%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h2 id="1-io流"><a href="#1-io流" class="headerlink" title="1. io流"></a>1. io流</h2><h3 id="1-1-oi流概念"><a href="#1-1-oi流概念" class="headerlink" title="1.1 oi流概念"></a>1.1 oi流概念</h3><p>​java的io是实现输入和输出的基础，可以方便的实现数据的输入和输出操作。</p><p>在java中把对于输入&#x2F;输入操作是以流的方式进行操作的。java.io 包下提供了大</p><p>量的供我们使用的操作【流】的方法和接口，用于进行各类数据的处理和输。</p><p>​计算机的输入和输出都是通过二进制来完成的。在网络中我们要传递数据就要将数据【流化】，换句话说就是讲文件、复杂的对象转化成能够在网络上传输的一个个的0和1。</p><h3 id="1-2-文件操作"><a href="#1-2-文件操作" class="headerlink" title="1.2 文件操作"></a>1.2 文件操作</h3><p>​在Java中，File类是java.io 包中唯一代表磁盘文件本身的对象。File 类定义了</p><p>一些与平台无关的方法来操作文件，File类主要用来获取或处理与磁盘文件相关</p><p>的信息，像文件名、文件路径、访问权限和修改日期等，还可以浏览子目录层</p><p>次结构。<br>    File类表示处理文件和文件系统的相关信息。也就是说，File类不具有从文件</p><p>读取信息和向文件写入信息的功能，它仅描述文件本身的属性。</p><h3 id="1-3-文件路径"><a href="#1-3-文件路径" class="headerlink" title="1.3 文件路径"></a>1.3 文件路径</h3><p>正斜杠，又称左斜杠，符号是”&#x2F;”；反斜杠，也称右斜杠，符号是””。</p><p>在Unix&#x2F;Linux中，路径的分隔采用正斜杠””，比如”&#x2F;home&#x2F;hutaow”；而在、、</p><p>Windows中，路径分隔采用反斜杠”，比如”C:1WindowsiSystem”</p><p>在java当中反斜杠代表的是转义:<br>        比如:制表符（也叫)的功能是在不使用表格的情况下在垂直方向按列对齐文本，就是咱们的tab键。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="/2023/01/17/java/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2023/01/17/java/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h4 id="1-1-正则表达式"><a href="#1-1-正则表达式" class="headerlink" title="1.1 正则表达式"></a>1.1 正则表达式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[abc] <span class="comment">//只能是abc</span></span><br><span class="line">[^abc] <span class="comment">//除了abc之外的任何字符</span></span><br><span class="line">[a-zA-Z] <span class="comment">//a到zA到Z</span></span><br><span class="line">[a-d&#123;,-p&#125;] <span class="comment">//a到D 或</span></span><br><span class="line">[a-z] <span class="comment">// 匹配所有的小写字母 </span></span><br><span class="line">[A-Z] <span class="comment">// 匹配所有的大写字母 </span></span><br><span class="line">[a-zA-Z] <span class="comment">// 匹配所有的字母 </span></span><br><span class="line">[<span class="number">0</span>-<span class="number">9</span>] <span class="comment">// 匹配所有的数字 </span></span><br><span class="line">[<span class="number">0</span>-<span class="number">9</span>\.\-] <span class="comment">// 匹配所有的数字，句号和减号 </span></span><br><span class="line">[ \f\r\t\n] <span class="comment">// 匹配所有的白字符</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/2023/01/17/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2023/01/17/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h3 id="1-1-数据结构"><a href="#1-1-数据结构" class="headerlink" title="1.1 数据结构"></a>1.1 数据结构</h3><h4 id="1-数据结构概述"><a href="#1-数据结构概述" class="headerlink" title="1.数据结构概述"></a>1.数据结构概述</h4><ul><li><p>数据结构是计算机底层存储、组织数据的方式。</p></li><li><p>是指数据相互之间是以什么方式排列在一起的。</p></li><li><p>数据结构是为了更加方便的管理和使用数据，需要结合具体的业务场景来进行选择。</p></li><li><p>一般情况下，精心选择的数据结构可以带来更高的运行或者存储效率。</p></li></ul><h4 id="2-栈"><a href="#2-栈" class="headerlink" title="2.栈"></a>2.栈</h4><p>​栈的特点：后进先出，先进后出</p><p>​数据进入到栈模型中叫：压栈&#x2F;进栈</p><p>​数据离开到栈模型中叫：弹栈&#x2F;出栈</p><p><img src="https://s2.loli.net/2022/12/29/pZ3GQi6Ez8cU1Pu.png" alt="image-20221210163543807"></p><h4 id="3-队列"><a href="#3-队列" class="headerlink" title="3.队列"></a>3.队列</h4><p>​栈的特点：先进先出，后进后出</p><p>​数据从后端进入队列模型的过程为入队列</p><p>​数据从前端离开队列模型的过程为出队列</p><p><img src="https://s2.loli.net/2022/12/29/P1UoIh5GDc8mXMY.png" alt="image-20221210164304062"></p><h4 id="4-数组"><a href="#4-数组" class="headerlink" title="4.数组"></a>4.数组</h4><p>​数组是一种查询快，增删慢的模型</p><ul><li>查询速度快：查询数据通过地址值和索引定位，查询任意数据耗时相同。（元素在内存中是连续存储的）</li><li>删除效率低：要将原始数据删除，同时后面每个数据前移。</li><li>添加效率极低：添加位置后的每个数据后移，再添加元素</li></ul><p><img src="https://s2.loli.net/2022/12/29/DTUVcwIORudGyM6.png" alt="image-20221210165235563"></p><h4 id="5-链表"><a href="#5-链表" class="headerlink" title="5.链表"></a>5.链表</h4><p>​链表中的结点是独立的对象，在内存中是不连续的，每个结点包含数据值和下一个结点的地址。<br>​链表查询慢，无论查询哪个数据都要从头开始找。</p><p>​链表增删快</p><p><img src="https://s2.loli.net/2022/12/29/ivdE3I9flWgRpVe.png" alt="image-20221210165852839"></p><p><img src="https://s2.loli.net/2022/12/29/8frJW4jblLydTUG.png" alt="image-20221210170548621"></p><h4 id="6-树"><a href="#6-树" class="headerlink" title="6.树"></a>6.树</h4><p><img src="https://s2.loli.net/2022/12/29/AamhUJ2N93tiRQZ.png" alt="image-20221210172134798"></p><h5 id="6-1-二叉查找树"><a href="#6-1-二叉查找树" class="headerlink" title="6.1 二叉查找树"></a>6.1 二叉查找树</h5><p>​二叉查找树，又称二叉排序树或者二叉搜索树。</p><p>特点：</p><ul><li>每一个节点上最多有两个子节点</li><li>任意节点左子树上的值都小于当前节点</li><li>岁任意节点右子树上的值都大于当前节点</li></ul><p><img src="https://s2.loli.net/2022/12/29/Az5ZCWw4gQRed96.png" alt="image-20221210172634439"></p><p><img src="https://s2.loli.net/2022/12/29/LgdvOkmNbpMn2l6.png" alt="image-20221210172917347"></p><p>二叉树遍历方式</p><ol><li>前序遍历<ul><li>从根结点开始，然后按照当前结点，左子结点，右子结点的顺序遍历</li></ul></li><li>中序遍历<ul><li>从最左边的子节点开始，然后按照左子结点，当前结点，右子结点的顺序遍历</li></ul></li><li>后序遍历<ul><li>从最左边的子节点开始，然后按照左子结点，右子结点，当前结点的顺序遍历</li></ul></li><li>层序遍历<ul><li>从根节点开始一层一层的遍历</li></ul></li></ol><h5 id="6-3-平衡二叉树-左旋"><a href="#6-3-平衡二叉树-左旋" class="headerlink" title="6.3 平衡二叉树(左旋)"></a>6.3 平衡二叉树(左旋)</h5><p>​任意节点左右节点树高度不超过1</p><ul><li>确定支点：从添加的节点开始，不断的往父节点找不平衡的节点</li><li>以不平衡的点作为支点</li><li>把支点左旋降级，变成左子节点</li><li>晋升原来的右子节点</li></ul><p><img src="https://s2.loli.net/2022/12/29/ESIYyTHR2DQPBaK.png" alt="image-20221211104451268"></p><h5 id="6-3-平衡二叉树-右旋"><a href="#6-3-平衡二叉树-右旋" class="headerlink" title="6.3 平衡二叉树(右旋)"></a>6.3 平衡二叉树(右旋)</h5><ul><li>确定支点：从添加的节点开始，不断的往父节点找不平衡的节点</li><li>以不平衡的点作为支点</li><li>把支点右旋降级，变成右子节点</li><li>引晋升原来的左子节点</li></ul><p><img src="https://s2.loli.net/2022/12/29/MweAU9WH8Xtfb61.png" alt="image-20221211105618418"></p><p><img src="https://s2.loli.net/2022/12/29/Cd9pUWqDevZxcVj.png" alt="image-20221211105800905"></p><h4 id="7-红黑树"><a href="#7-红黑树" class="headerlink" title="7.红黑树"></a>7.红黑树</h4><ul><li>红黑树是一种自平衡的二叉查找树，是计算机科学中用到的一种数据结构。</li><li>1972年出现，当时被称之为平衡二叉B树。后来，1978年被修改为如今的”红黑树”。</li><li>它是一种特殊的二叉查找树，红黑树的每一个节点上都有存储位表示节点的颜色，</li><li>每一个节点可以是红或者黑；红黑树不是高度平衡的，它的平衡是通过”红黑规则”进行实现的</li></ul><p><img src="https://s2.loli.net/2022/12/29/ZAdy9DFpcmjYkIW.png" alt="image-20221212100901253"></p><h5 id="7-1红黑规则"><a href="#7-1红黑规则" class="headerlink" title="7.1红黑规则"></a>7.1红黑规则</h5><p>① 每一个节点或是红色的，或者是黑色的</p><p>② 根节点必须是黑色</p><p>③如果一个节点没有子节点或者父节点，则该节点相应的指针属性值为Nil，这些Nil视为叶节点，每个叶节点(Nil)是黑色的</p><p>④ 如果某一个节点是红色，那么它的子节点必须是黑色(不能出现两个红色节点相连的情况)</p><p>③ 对每一个节点，从该节点到其所有后代叶节点的简单路径上，均包含相同数目的黑色节点;</p><p><img src="https://s2.loli.net/2022/12/29/gVAvj3Rsk5Jf4YW.png" alt="image-20221212101423432"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>面向对象</title>
      <link href="/2023/01/17/java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
      <url>/2023/01/17/java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="1-5-1-面向对象"><a href="#1-5-1-面向对象" class="headerlink" title="1.5.1 面向对象"></a>1.5.1 面向对象</h3><h4 id="1-5-1-1-类与对象"><a href="#1-5-1-1-类与对象" class="headerlink" title="1.5.1.1 类与对象"></a>1.5.1.1 类与对象</h4><p>​类是一个模板，它描述一类对象的行为和状态。定义类就是定义类的属性与行为（方法）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[ 权限修饰符] [ 修饰符] class 类名&#123;</span><br><span class="line">    成员变量;</span><br><span class="line">    类方法;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span>&#123;</span><br><span class="line">    String employeeName;  <span class="comment">//类的属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">name</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(employeeName)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​对象是类的实例，定义对象和定义变量一样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">类名 对象名</span><br><span class="line">在使用对象之前必须给他分配内存,必须通过<span class="keyword">new</span> 关键字来实现</span><br><span class="line">Empoyee =<span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">Student</span> <span class="variable">s</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">Student 是一个引用数据类型</span><br><span class="line">s是一个变量名</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Student</span> 是一个学生对象</span><br><span class="line">读取数据：引用.变量名</span><br><span class="line">s.name</span><br><span class="line">修改数据：引用.变量名=值;</span><br></pre></td></tr></table></figure><h4 id="1-5-1-2-封装"><a href="#1-5-1-2-封装" class="headerlink" title="1.5.1.2 封装"></a>1.5.1.2 封装</h4><pre><code> 封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。</code></pre><p>要访问该类的代码和数据，必须通过严格的接口控制。</p><p>优点：</p><ul><li><p>良好的封装能够减少耦合。</p></li><li><p>类内部的结构可以自由修改。</p></li><li><p>可以对成员变量进行更精确的控制。</p></li><li><p>隐藏信息，实现细节</p></li><li><p>安全性高</p></li><li><p>封装之后才可以成为对象，真正的独立体</p></li><li><p>封装之后可以重复使用</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="1-5-1-3-继承"><a href="#1-5-1-3-继承" class="headerlink" title="1.5.1.3 继承"></a>1.5.1.3 继承</h4><p>​继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。</p><ul><li>子类拥有父类非 private 的属性、方法。</li><li>子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。</li><li>子类可以用自己的方式实现父类的方法。</li><li>Java 的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如 B 类继承 A 类，C 类继承 B 类，所以按照关系就是 B 类是 C 类的父类，A 类是 B 类的父类，这是 Java 继承区别于 C++ 继承的一个特性。</li><li>提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class 父类 &#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class 子类 extends 父类 &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-5-1-4-多态"><a href="#1-5-1-4-多态" class="headerlink" title="1.5.1.4 多态"></a>1.5.1.4 多态</h4><p>​多态是同一个行为具有多个不同表现形式或形态的能力。</p><p>​优点</p><ul><li>消除类型之间的耦合关系</li><li>可替换性</li><li>可扩充性</li><li>接口性</li><li>灵活性</li><li>简化性</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ydl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test12</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">    p.drink();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drink</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;water&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drink</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;tea&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>要有重写</li><li>有继承</li><li>父类引用指向子类对象</li></ol><h4 id="1-5-1-5构造方法"><a href="#1-5-1-5构造方法" class="headerlink" title="1.5.1.5构造方法"></a>1.5.1.5构造方法</h4><p>​构造方法包含初始化类的成员变量的代码，当类的对象在创建时，它自动执行，不管谁创建类对象，构造方法被激活，成员变量被初始化。</p><p>​特征：</p><ul><li><p>它具有与类相同的名称</p></li><li><p>不能有返回值，写上void就是普通方法</p></li><li><p>它不能在用return语句返回一个值</p></li><li><p>构造方法必须与类名一致        </p><p>  public class Employee {<br>  String EmployeeName;   &#x2F;&#x2F;姓名<br>  int EmployeeNo&#x3D;45;        &#x2F;&#x2F;编号<br>  double Salary;          &#x2F;&#x2F;薪水<br>  public Employee(){<br><br><br>  }</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">调用：</span><br><span class="line">普通方法有static：类名.方法名(实参);</span><br><span class="line">    普通方法没有static：引用.方法名（实参）;</span><br><span class="line">构造方法：在创建对象的时候被调用：new 构造方法（实参）</span><br></pre></td></tr></table></figure><h4 id="1-5-1-6-访问说明符和修饰符"><a href="#1-5-1-6-访问说明符和修饰符" class="headerlink" title="1.5.1.6  访问说明符和修饰符"></a>1.5.1.6  访问说明符和修饰符</h4><table><thead><tr><th align="left">修饰符</th><th align="left">当前类</th><th align="left">同一包内</th><th align="left">子孙类(同一包)</th><th align="left">子孙类(不同包)</th><th align="left">其他包</th></tr></thead><tbody><tr><td align="left"><code>public</code></td><td align="left">Y</td><td align="left">Y</td><td align="left">Y</td><td align="left">Y</td><td align="left">Y</td></tr><tr><td align="left"><code>protected</code></td><td align="left">Y</td><td align="left">Y</td><td align="left">Y</td><td align="left">Y&#x2F;N</td><td align="left">N</td></tr><tr><td align="left"><code>default</code></td><td align="left">Y</td><td align="left">Y</td><td align="left">Y</td><td align="left">N</td><td align="left">N</td></tr><tr><td align="left"><code>private</code></td><td align="left">Y</td><td align="left">N</td><td align="left">N</td><td align="left">N</td><td align="left">N</td></tr></tbody></table><h5 id="1-final-修饰符："><a href="#1-final-修饰符：" class="headerlink" title="1.final 修饰符："></a>1.final 修饰符：</h5><ul><li>一个final 不能被继承</li><li>一个final 不能被子类重载</li><li>final 成员变量不能在被初始化后被改变</li><li>在final类里面所有的成员变量和方法都是final类型</li></ul><h5 id="2-abstract修饰符"><a href="#2-abstract修饰符" class="headerlink" title="2.abstract修饰符"></a>2.abstract修饰符</h5><ul><li>类中包含一个明确声明的抽象方法</li><li>类中的任何一个父类包含一个没有实现的抽象方法</li><li>抽象类必须有子类</li></ul><h4 id="1-5-1-7方法的重载"><a href="#1-5-1-7方法的重载" class="headerlink" title="1.5.1.7方法的重载"></a>1.5.1.7方法的重载</h4><ul><li>方法名一样，形式参数不一样</li><li>方法的参数类型，参数个不一样</li><li>方法的返回类型可以不相同</li><li>方法的修饰符可以不相同</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> &#123;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">return</span> x+y;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z)</span>&#123;</span><br><span class="line">     <span class="keyword">return</span> x+y+z;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> name)</span>&#123;</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="1-5-1-8this关键字"><a href="#1-5-1-8this关键字" class="headerlink" title="1.5.1.8this关键字"></a>1.5.1.8this关键字</h4><p><img src="https://s2.loli.net/2022/12/29/wkF5CU4zEJtOBNu.png" alt="image-20221130155516527"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    String EmployeeName;   <span class="comment">//姓名</span></span><br><span class="line">    <span class="type">int</span> EmployeeNo=<span class="number">45</span>;        <span class="comment">//编号</span></span><br><span class="line">    <span class="type">double</span> Salary;          <span class="comment">//薪水</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String employeeName, <span class="type">int</span> employeeNo, <span class="type">double</span> salary)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.EmployeeName=EmployeeName;</span><br><span class="line">        <span class="built_in">this</span>.EmployeeNo=EmployeeNo;</span><br><span class="line">        <span class="built_in">this</span>.Salary=Salary;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-5-1-9super关键字"><a href="#1-5-1-9super关键字" class="headerlink" title="1.5.1.9super关键字"></a>1.5.1.9super关键字</h4><p>使用super调用父类的方法和属性，super 可以理解为是指向自己超（父）类对象的一个指针，而这个超类指的是离自己最近的一个父类。</p><ol><li>父类开始找，父类没有才开始找子类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ydl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    String name=<span class="string">&quot;hdjk&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ect</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;在吃饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ydl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>  String name=<span class="string">&quot;金中豪&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        String name=<span class="string">&quot;wang&quot;</span>;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ydl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Son</span> <span class="variable">son</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line"></span><br><span class="line">        son.run();</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="1-5-2-0-toString方法"><a href="#1-5-2-0-toString方法" class="headerlink" title="1.5.2.0 toString方法"></a>1.5.2.0 toString方法</h4><p>​toString() 方法用于返回以一个字符串表示的 Number 对象值。</p><p>如果方法使用了原生的数据类型作为参数，返回原生数据类型的 String 对象值。如果方法有两个参数， 返回用第二个参数指定基数表示的第一个参数的字符串表示形式</p><h4 id="1-5-2-1-对象转型"><a href="#1-5-2-1-对象转型" class="headerlink" title="1.5.2.1 对象转型"></a>1.5.2.1 对象转型</h4><ul><li>向上转型：子类对象转为父类，向上转型不需要显示转化。Father father &#x3D;son  向上转型会丢失子类原来有的特性。</li><li>向下转型：父类对象转为子类，向下转型需要强制类型转换。Son son&#x3D;(son)Father</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Father s=<span class="keyword">new</span> <span class="title class_">Son</span>();  <span class="comment">//自动类型转换</span></span><br><span class="line">        s.ect();</span><br><span class="line">        <span class="comment">//强制类型转换</span></span><br><span class="line">        Father s2=<span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        <span class="type">Son</span> <span class="variable">s3</span> <span class="operator">=</span> (Son) s2;</span><br><span class="line">        s3.pary();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="1-5-2-2-抽象类"><a href="#1-5-2-2-抽象类" class="headerlink" title="1.5.2.2 抽象类"></a>1.5.2.2 抽象类</h4><p>​用abstract关键字来修饰一个类时这个类就是抽象类。</p><ul><li>抽象类必须使用abstract关键字来修饰，抽象方法也必须用abstract来修饰。</li><li>抽象类不能被实例化，不能使用new关键字生成对象。</li><li>抽象方法只需声明，不需实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">gh</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">M1</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>类和类叫继承，类和接口之间叫实现。</li><li>继承使用extends 关键字。</li><li>实现用implements 关键字。</li><li>抽象使用abstract。</li><li>当一个非抽象类实现接口的话，必须将接口里面的抽象方法全部重写。</li><li>当一个非抽象类实现接口的时候必须将接口中所有方法加以实现。</li><li>一个类可以实现多个接口</li><li>extends和implements可以共存，extends在前，implements在后。</li><li>使用接口，写接口的时候，可以使用多态（父类引用指向子类对象）</li></ol><h4 id="1-5-2-3接口"><a href="#1-5-2-3接口" class="headerlink" title="1.5.2.3接口"></a>1.5.2.3接口</h4><p>​接口是一种特殊的抽象类，这种抽象类中只包含常量和方法的定义。</p><ul><li>接口是完成抽象的</li><li>接口支持多继承</li><li>接口中只包含部分内容，常量，抽象方法</li><li>接口中所有的元素都是public</li><li>接口中不能有方法体</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> interface 接口名&#123;</span><br><span class="line">    <span class="comment">//常量</span></span><br><span class="line">    <span class="comment">//方法声明</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class 类名 extends 基类 implements 接口 接口&#123;</span><br><span class="line"><span class="comment">//成员定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-5-2-4代码块"><a href="#1-5-2-4代码块" class="headerlink" title="1.5.2.4代码块"></a>1.5.2.4代码块</h4><p>​代码块又称初始化块，属于类中的成员，它讲的是逻辑代码块封装在方法体中通过{}包裹，代码块没有方法名，返回值，只有方法体，而且不通过对象和类进行调用，他会在类加载的时候调用，或创建对象的时候隐式调用。</p><ol><li>静态代码块</li></ol><p>一个类在加载的时候调用，做一些全局初始化的工作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​2.实例代码块</p><p>每次创建实例都会被调用一次</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ydl.template;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.ydl.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">block</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;nihao&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;buhap1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">block</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">block</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">block</span>();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="1-5-2-4-静态方法和成员方法"><a href="#1-5-2-4-静态方法和成员方法" class="headerlink" title="1.5.2.4 静态方法和成员方法"></a>1.5.2.4 静态方法和成员方法</h4><p>​静态方法的调用无论在那都是类名.方法名</p><p>​静态方法中调用实例方法必须new一个对象。</p><h4 id="1-5-2-4-内部类"><a href="#1-5-2-4-内部类" class="headerlink" title="1.5.2.4 内部类"></a>1.5.2.4 内部类</h4><p>​内部类就是在类里面定义了一个类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ydl.template;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.xml.soap.Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sperlinked</span> &#123;</span><br><span class="line">    Node head;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="1-5-2-5-Java-异常处理"><a href="#1-5-2-5-Java-异常处理" class="headerlink" title="1.5.2.5 Java 异常处理"></a>1.5.2.5 Java 异常处理</h4><p>​异常是程序中的一些错误，但并不是所有的错误都是异常，并且错误有时候是可以避免的。</p><p>比如说，你的代码少了一个分号，那么运行出来结果是提示是错误 java.lang.Error；如果你用System.out.println(11&#x2F;0)，那么你是因为你用0做了除数，会抛出 java.lang.ArithmeticException 的异常。</p><p>异常发生的原因有很多，通常包含以下几大类：</p><ul><li>用户输入了非法数据。</li><li>要打开的文件不存在。</li><li>网络通信时连接中断，或者JVM内存溢出。</li></ul><p>这些异常有的是因为用户错误引起，有的是程序错误引起的，还有其它一些是因为物理错误引起的。-</p><p>要理解Java异常处理是如何工作的，你需要掌握以下三种类型的异常：</p><ul><li><strong>检查性异常：</strong>最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。</li><li><strong>运行时异常：</strong> 运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。</li><li><strong>错误：</strong> 错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">捕获异常</span><br><span class="line">使用 <span class="keyword">try</span> 和 <span class="keyword">catch</span> 关键字可以捕获异常。<span class="keyword">try</span>/<span class="keyword">catch</span> 代码块放在异常可能发生的地方。</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>/<span class="keyword">catch</span>代码块中的代码称为保护代码，使用 <span class="keyword">try</span>/<span class="keyword">catch</span> 的语法如下：</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 程序代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(ExceptionName e1)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//Catch 块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-5-2-5throws-x2F-throw-关键字"><a href="#1-5-2-5throws-x2F-throw-关键字" class="headerlink" title="1.5.2.5throws&#x2F;throw 关键字"></a>1.5.2.5throws&#x2F;throw 关键字</h4><p>​如果一个方法没有捕获到一个检查性异常，那么该方法必须使用 throws 关键字来声明。throws 关键字放在方法签名的尾部。</p><p>也可以使用 throw 关键字抛出一个异常，无论它是新实例化的还是刚捕获到的。</p><p>下面方法的声明抛出一个 RemoteException 异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">className</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deposit</span><span class="params">(<span class="type">double</span> amount)</span> <span class="keyword">throws</span> RemoteException</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// Method implementation</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RemoteException</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//Remainder of class definition</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如，下面的方法声明抛出 RemoteException 和 InsufficientFundsException：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">className</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(<span class="type">double</span> amount)</span> <span class="keyword">throws</span> RemoteException,</span><br><span class="line">                              InsufficientFundsException</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">// Method implementation</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//Remainder of class definition</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-5-2-1-集合"><a href="#1-5-2-1-集合" class="headerlink" title="1.5.2.1 集合"></a>1.5.2.1 集合</h4><p>​数组就是一个集合。其实集合就是一个容器。可以用来容纳其他类型的数据，集合是一个容器，是一个载体，可以一个容纳多个数据。</p><p>​集合不能直接存储基本数据类型，也不能直接存储Java对象，集合中存储的Java对象的内存地址，也可以说是引用。</p><ol><li>集合在Java中本身就是一个容器，是一个对象，也有内存地址。</li><li>集合在任何时候存储的都是一个引用。</li><li>Java中每一个不同集合，底层都会对应不同的数据结构，往不同的集合中存储元素等于将数据放入了数据结构当中。不同的数据结构数据的存储方式不同。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>集合</title>
      <link href="/2023/01/17/java/%E9%9B%86%E5%90%88/"/>
      <url>/2023/01/17/java/%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h3 id="1-1-集合"><a href="#1-1-集合" class="headerlink" title="1.1 集合"></a>1.1 集合</h3><h4 id="1-1-2-集合的体系结构"><a href="#1-1-2-集合的体系结构" class="headerlink" title="1.1.2 集合的体系结构"></a>1.1.2 集合的体系结构</h4><p>集合框架被设计成要满足以下几个目标。</p><ul><li><p>该框架必须是高性能的。基本集合（动态数组，链表，树，哈希表）的实现也必须是高效的。</p></li><li><p>该框架允许不同类型的集合，以类似的方式工作，具有高度的互操作性。</p></li><li><p>对一个集合的扩展和适应必须是简单的。</p></li><li><p>list系列集合：添加的元素是有序，可重复，有索引。</p></li><li><p>set系列集合：添加元素是无序，不重复，无索引</p></li><li><p>collection是单列集合的祖宗接口，它的功能是全部单列集合都可以继承使用的。</p></li></ul><p>常见的方法</p><p><img src="https://s2.loli.net/2022/12/29/8Kzhlj4a1LI2fRO.png" alt="image-20221209153927894"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ydl.Coolection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * public boolean add(E e)   添加</span></span><br><span class="line"><span class="comment"> * public void clear()       清空</span></span><br><span class="line"><span class="comment"> * public boolean remove(E e)  删除</span></span><br><span class="line"><span class="comment"> * public boolean contains（Object obj） 判断是否包含</span></span><br><span class="line"><span class="comment"> * public boolean isEmpty()  判断是否为空</span></span><br><span class="line"><span class="comment"> * public int size() 集合长度</span></span><br><span class="line"><span class="comment"> * 注意 ：</span></span><br><span class="line"><span class="comment"> * collection是一个接口 我们不能直接创建他的对象，</span></span><br><span class="line"><span class="comment"> * 我们学习他的方法的时候只能创建他的实现类的对象，</span></span><br><span class="line"><span class="comment"> * 实现类Arraylist</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Collection&lt;String&gt; coll= <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="comment">//添加元素</span></span><br><span class="line">        <span class="comment">//如果我们要往list集合中添加数据，那么方法返回true 因为list集合可以重复</span></span><br><span class="line">        coll.add(<span class="string">&quot;aaaa&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;aaaa&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line"><span class="comment">//        //清空</span></span><br><span class="line"><span class="comment">//        coll.clear();</span></span><br><span class="line">        <span class="comment">//删除  不能通过索引删除</span></span><br><span class="line">        coll.remove(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        System.out.println(coll);</span><br><span class="line">        <span class="comment">//判断</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">aaa</span> <span class="operator">=</span> coll.contains(<span class="string">&quot;aaaa&quot;</span>);</span><br><span class="line">        System.out.println(aaa);</span><br><span class="line">        <span class="comment">//判断集合是否为空</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">empty</span> <span class="operator">=</span> coll.isEmpty();</span><br><span class="line">        System.out.println(empty);</span><br><span class="line">        <span class="comment">//判断长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> coll.size();</span><br><span class="line">        System.out.println(size);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="1-1-3collection遍历方式"><a href="#1-1-3collection遍历方式" class="headerlink" title="1.1.3collection遍历方式"></a>1.1.3collection遍历方式</h4><h5 id="1-迭代器遍历"><a href="#1-迭代器遍历" class="headerlink" title="1.迭代器遍历"></a>1.迭代器遍历</h5><p>​迭代器在Java中的类是iterator ，迭代器是集合专用的遍历方式。</p><p><img src="https://s2.loli.net/2022/12/29/uS81aET7c9OYbCU.png" alt="image-20221209172523274"></p><p><img src="https://s2.loli.net/2022/12/29/32AErTN6unq9svj.png" alt="image-20221210103457393"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ydl.Coolection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建集合并添加元素</span></span><br><span class="line">        Collection&lt;String&gt;  coll= <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        coll.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;ddd&quot;</span>);</span><br><span class="line">        <span class="comment">//2.获取迭代器对象,默认指向0索引处</span></span><br><span class="line">        Iterator&lt;String&gt; it= coll.iterator();</span><br><span class="line">        <span class="comment">//3.利用循环获取元素</span></span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">            <span class="comment">//获取元素，并移动指针</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> it.next();</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当迭代器结束，指针指向最后一个元素，若在次调用it.next()</span></span><br><span class="line">        <span class="comment">//会报NoSuchElementException</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>报错NoSuchElementException</li><li>,迭代器遍历完毕，指针不会复位</li><li>循环中只能用一次next方法</li><li>迭代器遍历时，不能用集合的方法进行增加或者删除</li></ul><h5 id="2-增强for遍历"><a href="#2-增强for遍历" class="headerlink" title="2.增强for遍历"></a>2.增强for遍历</h5><ul><li>增强fo的底层就是迭代器，为了简化迭代器的代码书写的。</li><li>它是DK5之后出现的，其内部原理就是一个Iteratori迭代器。</li><li>所有的单列集合和数组才能用增强fo进行遍历。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">增强<span class="keyword">for</span>格式：</span><br><span class="line"><span class="keyword">for</span>(数据类型变量名：集合/数组)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">快速生成方式：</span><br><span class="line">    集合的名字+<span class="keyword">for</span> 回车</span><br><span class="line">        </span><br><span class="line">使用增强<span class="keyword">for</span>不会改变集合中原来的数据</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ydl.Coolection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建集合并添加元素</span></span><br><span class="line">        Collection&lt;String&gt; coll= <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        coll.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;ddd&quot;</span>);</span><br><span class="line">        <span class="comment">//增强for遍历</span></span><br><span class="line">        <span class="keyword">for</span> (String s: coll) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-lambda表达式遍历"><a href="#3-lambda表达式遍历" class="headerlink" title="3.lambda表达式遍历"></a>3.lambda表达式遍历</h5><p>​得益于DK8开始的新技术Lambda表达式，提供了一种更简单、更直接的遍历集合的方式。</p><p><img src="https://s2.loli.net/2022/12/29/GtuJFi7oxwMsg9Z.png" alt="image-20221210113032495"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ydl.Coolection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建集合并添加元素</span></span><br><span class="line">        Collection&lt;String&gt; coll= <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        coll.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;ddd&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        coll.forEach((String s) -&gt;&#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(s);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        );</span></span><br><span class="line">        coll.forEach(s -&gt; System.out.println(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-list集合"><a href="#1-2-list集合" class="headerlink" title="1.2 list集合"></a>1.2 list集合</h3><ul><li>collection的方法都继承了</li><li>list集合因为都有索引，所以多了很多索引操作的方法 ·</li></ul><p><img src="https://s2.loli.net/2022/12/29/pUTiWYylVnC1b3E.png" alt="image-20221210143014838"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">list_test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建集合</span></span><br><span class="line">        List&lt;String&gt; list= <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//添加元素</span></span><br><span class="line">        list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="comment">//在1索引处添加qqqqq</span></span><br><span class="line">        list.add(<span class="number">1</span>,<span class="string">&quot;qqqqq&quot;</span>);</span><br><span class="line">        <span class="comment">//删除指定索引</span></span><br><span class="line">        list.remove(<span class="number">0</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        list.set(<span class="number">1</span>,<span class="string">&quot;56566&quot;</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        list.get(<span class="number">0</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-collection遍历方式"><a href="#1-collection遍历方式" class="headerlink" title="1.collection遍历方式"></a>1.collection遍历方式</h5><ul><li>迭代器遍历</li><li>列表迭代器遍历</li><li>增强for遍历</li><li>lambda表达式遍历</li><li>普通for遍历</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ydl.Coolection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.ListIterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">list_test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建集合</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">        <span class="comment">//迭代器遍历</span></span><br><span class="line">        Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">next</span> <span class="operator">=</span> it.next();</span><br><span class="line">            System.out.println(next);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;+++++++++++++++++++++++++++++++++++++++++&quot;</span>);</span><br><span class="line">        <span class="comment">//增强for</span></span><br><span class="line">        <span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;+++++++++++++++++++++++++++++++++++++++++&quot;</span>);</span><br><span class="line">        <span class="comment">//lambda表达式</span></span><br><span class="line">        list.forEach(s -&gt; System.out.println(s));</span><br><span class="line">        <span class="comment">//普通for</span></span><br><span class="line">        System.out.println(<span class="string">&quot;+++++++++++++++++++++++++++++++++++++++++&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> list.get(i);</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//列表迭代器</span></span><br><span class="line">        <span class="comment">//获取迭代器对象,默认指向0,在遍历的时候可以添加元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;+++++++++++++++++++++++++++++++++++++++++&quot;</span>);</span><br><span class="line">        ListIterator&lt;String&gt; ita = list.listIterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (ita.hasNext()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> ita.next();</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;1&quot;</span>.equals(str))&#123;</span><br><span class="line">                ita.add(<span class="string">&quot;748545&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/12/29/ym3eCKAZ49rNzOf.png" alt="image-20221210155011708"></p><h3 id="1-3set-集合"><a href="#1-3set-集合" class="headerlink" title="1.3set 集合"></a>1.3set 集合</h3><p>set集合实现类</p><ul><li>HashSet：无序、不重复、无索引</li><li>LinkedHashSet：有序、不重复、无索引</li><li>TreeSet:可排序、不重复、无索引</li></ul><p><img src="D:\学习笔记\图片\image-20221212102141001.png" alt="image-20221212102141001"></p><p>利用Set系列的集合，添加字符串，并使用多种方式遍历。</p><p>① 迭代器</p><p>② 增强for</p><p>③ Lambda表达式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ydl.Coolection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Set_Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个集合对象</span></span><br><span class="line">        Set&lt;String&gt; s= <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> s.add(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b2</span> <span class="operator">=</span> s.add(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b3</span> <span class="operator">=</span> s.add(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b4</span> <span class="operator">=</span> s.add(<span class="string">&quot;王五&quot;</span>);</span><br><span class="line">        <span class="comment">//无序，不重复</span></span><br><span class="line">        System.out.println(s);</span><br><span class="line">        <span class="comment">//迭代器遍历</span></span><br><span class="line">        Iterator&lt;String&gt; iterator = s.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;++++++++++++++++++++++++&quot;</span>);</span><br><span class="line">        <span class="comment">//增强for</span></span><br><span class="line">        <span class="keyword">for</span> (String s1 : s) &#123;</span><br><span class="line">            System.out.println(s1);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;++++++++++++++++&quot;</span>);</span><br><span class="line">        <span class="comment">//lambda表达式</span></span><br><span class="line">        s.forEach(a -&gt; System.out.println(a));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HashSet底层原理</p><ul><li>HashSet集合底层采取哈希表存储数据</li><li>哈希表是一种对于增删改查数据性能都较好的结构</li><li>哈希表组成</li><li>JDK8之前：数组+链表</li><li>JDK8开始：数组+链表+红黑树</li></ul><p>哈希值</p><ul><li>根据hashCode方法算出来的int类型的整数</li><li>该方法定义在Object类中，所有对象都可以调用，默认使用地址值进行计算</li><li>一般情况下，会重写hashCode方法，利用对象内部的属性值计算哈希值</li></ul><p>对象的哈希值特点</p><ul><li>如果没有重写hashCode方法，不同对象计算出的哈希值是不同的</li><li>如果已经重写hashcode方法，不同的对象只要属性值相同，计算出的哈希值就是一样的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ydl.Coolection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hashset_Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">20</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">20</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">24</span>);</span><br><span class="line">        System.out.println(s.hashCode());</span><br><span class="line">        System.out.println(s3.hashCode());</span><br><span class="line">        System.out.println(s2.hashCode());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ydl.Coolection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hashset_Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">20</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">20</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">24</span>);</span><br><span class="line">        System.out.println(s.hashCode());</span><br><span class="line">        System.out.println(s3.hashCode());</span><br><span class="line">        System.out.println(s2.hashCode());</span><br><span class="line">        HashSet&lt;Student&gt; hs= <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Student&gt;();</span><br><span class="line">        <span class="comment">//添加元素</span></span><br><span class="line">        hs.add(s);</span><br><span class="line">        hs.add(s3);</span><br><span class="line">        hs.add(s2);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        System.out.println(hs);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LinkedHashSet底层原理</p><ul><li>有序、不重复、无索引。</li><li>这里的有序指的是保证存储和取出的元素顺序一致</li><li>原理：底层数据结构是依然哈希表，只是每个元素又额外的多了一个双链表的机制记录存储的顺序</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ydl.Coolection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hashset_Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">20</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">20</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">24</span>);</span><br><span class="line">        System.out.println(s.hashCode());</span><br><span class="line">        System.out.println(s3.hashCode());</span><br><span class="line">        System.out.println(s2.hashCode());</span><br><span class="line">        LinkedHashSet&lt;Student&gt; hs= <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;Student&gt;();</span><br><span class="line">        <span class="comment">//添加元素</span></span><br><span class="line">        System.out.println(hs.add(s));</span><br><span class="line">        System.out.println(hs.add(s3));</span><br><span class="line">        System.out.println(hs.add(s2));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TreeSet的特点</p><ul><li><p>不重复、无索引、可排序</p></li><li><p>可排序：按照元素的默认规则（有小到大）排序。</p></li><li><p>TreeSet集合底层是基于红黑树的数据结构实现排序的，增删改查性能都较好。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ydl.Coolection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeSet_Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        TreeSet&lt;Integer&gt; ts= <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;Integer&gt;();</span><br><span class="line">        ts.add(<span class="number">8</span>);</span><br><span class="line">        ts.add(<span class="number">2</span>);</span><br><span class="line">        ts.add(<span class="number">7</span>);</span><br><span class="line">        ts.add(<span class="number">4</span>);</span><br><span class="line">        System.out.println(ts);</span><br><span class="line">        <span class="keyword">for</span> (Integer t : ts) &#123;</span><br><span class="line">            System.out.println(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/01/17/java/%E6%B3%9B%E5%9E%8B/"/>
      <url>/2023/01/17/java/%E6%B3%9B%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="1-5-2-泛型"><a href="#1-5-2-泛型" class="headerlink" title="1.5.2 泛型"></a>1.5.2 泛型</h3><h4 id="1-5-2-1泛型的定义"><a href="#1-5-2-1泛型的定义" class="headerlink" title="1.5.2.1泛型的定义"></a>1.5.2.1泛型的定义</h4><p>​看表面的意思是，泛型是广泛的，普通的类型，泛型可以帮助我们在【类型明确】的工作延迟到对象或方法的时候。意思就是我定义类不管他是什么类型，new这个对象或调用方法的时候才确定具体的类型。</p><p>​泛型类就是把泛型定义到类上，这样在用户使用类的时候才可以报类型确定下来。具体的方法就是&lt;&gt; 加一个未知数，通常用KTV大写字母表示，事实上是一个单词就行。</p><p><strong>java 中泛型标记符：</strong></p><ul><li><strong>E</strong> - Element (在集合中使用，因为集合中存放的是元素)</li><li><strong>T</strong> - Type（Java 类）</li><li><strong>K</strong> - Key（键）</li><li><strong>V</strong> - Value（值）</li><li><strong>N</strong> - Number（数值类型）</li><li><strong>？</strong> - 表示不确定的 java 类型</li></ul><p>​泛型方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ydl.template;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt;  T <span class="title function_">show</span><span class="params">(T t)</span>&#123;</span><br><span class="line">        System.out.println(t);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">show</span> <span class="operator">=</span> test.show(<span class="number">1425</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型通配符感觉和泛型方法差不多，只是不能用在使用前进行定义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericTest</span> &#123;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; name = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        List&lt;Integer&gt; age = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        List&lt;Number&gt; number = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Number&gt;();</span><br><span class="line">        </span><br><span class="line">        name.add(<span class="string">&quot;icon&quot;</span>);</span><br><span class="line">        age.add(<span class="number">18</span>);</span><br><span class="line">        number.add(<span class="number">314</span>);</span><br><span class="line"> </span><br><span class="line">        getData(name);</span><br><span class="line">        getData(age);</span><br><span class="line">        getData(number);</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getData</span><span class="params">(List&lt;?&gt; data)</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;data :&quot;</span> + data.get(<span class="number">0</span>));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-3-枚举enum"><a href="#1-5-3-枚举enum" class="headerlink" title="1.5.3 枚举enum"></a>1.5.3 枚举enum</h3><p>​在一些情况，一个类的对象有限且固定，比如说星期一到星期五，春夏秋冬等，这时候就可以使用。 </p><p>静态方法    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season DEFAULT= <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;秋天&quot;</span>, <span class="number">4</span>);</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">WINTER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;冬天&quot;</span>, <span class="number">3</span>);</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season SPRING= <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;春天&quot;</span>, <span class="number">1</span>);</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SUMMER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;夏天&quot;</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">SeasonEnum</span> &#123;</span><br><span class="line">    JANUARY, FEBRUARY, MARCH, APRIL, MAY, JUNE, JULY, AUGUST, SEPTEMBER, OCTOBER,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">SeasonEnum</span> &#123;</span><br><span class="line">    JANUARY, FEBRUARY, MARCH, APRIL, MAY, JUNE, JULY, AUGUST, SEPTEMBER, OCTOBER;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(SeasonEnum.JANUARY.name());<span class="comment">//姓名</span></span><br><span class="line">        System.out.println(SeasonEnum.JANUARY.ordinal()); <span class="comment">//序号</span></span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​enum 定义的枚举类默认继承了 java.lang.Enum 类，并实现了 java.lang.Serializable 和 java.lang.Comparable 两个接口。values(), ordinal() 和 valueOf() 方法位于 java.lang.Enum 类中：</p><ul><li>values() 返回枚举类中所有的值。</li><li>ordinal()方法可以找到每个枚举常量的索引，就像数组索引一样。</li><li>valueOf()方法返回指定字符串值的枚举常量。</li></ul><h3 id="1-5-4-多线程"><a href="#1-5-4-多线程" class="headerlink" title="1.5.4 多线程"></a>1.5.4 多线程</h3><p>​Java 给多线程编程提供了内置的支持。 一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。</p><p>​多线程是多任务的一种特别的形式，但多线程使用了更小的资源开销。</p><p>​这里定义和线程相关的另一个术语 - 进程：一个进程包括由操作系统分配的内存空间，包含一个或多个线程。一个线程不能独立的存在，它必须是进程的一部分。一个进程一直运行，直到所有的非守护线程都结束运行后才能结束。</p><p>​多线程能满足程序员编写高效率的程序来达到充分利用 CPU 的目的。</p><p>线程是一个动态执行的过程，它也有一个从产生到死亡的过程。</p><p>下图显示了一个线程完整的生命周期。</p><p><img src="https://www.runoob.com/wp-content/uploads/2014/01/java-thread.jpg" alt="img"></p><ul><li><p>新建状态:</p><p>  使用 <strong>new</strong> 关键字和 <strong>Thread</strong> 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 <strong>start()</strong> 这个线程。</p></li><li><p>就绪状态:</p><p>  当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。</p></li><li><p>运行状态:</p><p>  如果就绪状态的线程获取 CPU 资源，就可以执行 **run()**，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。</p></li><li><p>阻塞状态:</p><p>  如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种：</p><ul><li>等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。</li><li>同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)。</li><li>其他阻塞：通过调用线程的 sleep() 或 join() 发出了 I&#x2F;O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I&#x2F;O 处理完毕，线程重新转入就绪状态。</li></ul></li><li><p>死亡状态:</p><p>  一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。</p></li></ul><hr><h5 id="1-5-4-1线程的优先级"><a href="#1-5-4-1线程的优先级" class="headerlink" title="1.5.4.1线程的优先级"></a>1.5.4.1线程的优先级</h5><p>​每一个 Java 线程都有一个优先级，这样有助于操作系统确定线程的调度顺序。</p><p>Java 线程的优先级是一个整数，其取值范围是 1 （Thread.MIN_PRIORITY ） - 10 （Thread.MAX_PRIORITY ）。</p><p>默认情况下，每一个线程都会分配一个优先级 NORM_PRIORITY（5）。</p><p>具有较高优先级的线程对程序更重要，并且应该在低优先级的线程之前分配处理器资源。但是，线程优先级不能保证线程执行的顺序，而且非常依赖于平台。</p><hr><h5 id="1-5-4-2创建一个线程"><a href="#1-5-4-2创建一个线程" class="headerlink" title="1.5.4.2创建一个线程"></a>1.5.4.2创建一个线程</h5><p>Java 提供了三种创建线程的方法：</p><ul><li>通过实现 Runnable 接口；</li><li>通过继承 Thread 类本身；</li><li>通过 Callable 和 Future 创建线程。</li></ul><p>（1） 继承Thread重写run方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ydl.thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UseThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">UseThread</span>().start();  <span class="comment">//开启线程</span></span><br><span class="line">        System.out.println(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2） Runnable  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ydl.thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UseRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">UseRunnable</span>()).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">UseRunnable</span>()).sleep(<span class="number">20</span>);</span><br><span class="line">        System.out.println(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3） 通过 Callable 和 Future 创建线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ydl.thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Formattable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UseCallable</span>  <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// futureTask 保存返回值</span></span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>(<span class="keyword">new</span> <span class="title class_">UseCallable</span>());</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask).start(); <span class="comment">//开启线程</span></span><br><span class="line">        System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> futureTask.get(); <span class="comment">//等待线程获取返回值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        System.out.println(integer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ydl.thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Formattable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UseCallable</span>  <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> from;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> to;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UseCallable</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.from = from;</span><br><span class="line">        <span class="built_in">this</span>.to = to;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UseCallable</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i= from; i &lt; to; i++) &#123;</span><br><span class="line">            res +=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">int</span> res= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;<span class="number">100000</span> ; i++) &#123;</span><br><span class="line">            res+=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(end-start);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">        <span class="comment">//多线程</span></span><br><span class="line">        start = System.currentTimeMillis();</span><br><span class="line">        res= <span class="number">0</span>;</span><br><span class="line">        FutureTask[] futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;<span class="number">5</span> ; i++) &#123;</span><br><span class="line">            FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">UseCallable</span>(i*<span class="number">20000</span>,(i+<span class="number">1</span>)*<span class="number">20000</span>));</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(task).start(); <span class="comment">//开启线程</span></span><br><span class="line">            futureTask[i]=task;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; futureTask.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> (<span class="type">int</span>)futureTask[i].get();</span><br><span class="line">            res+=sum;</span><br><span class="line">        &#125;</span><br><span class="line">        end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(end-start);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下表列出了Thread类的一些重要方法：</p><table><thead><tr><th align="left"><strong>序号</strong></th><th align="left"><strong>方法描述</strong></th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>public void start()</strong> 使该线程开始执行；<strong>Java</strong> 虚拟机调用该线程的 run 方法。</td></tr><tr><td align="left">2</td><td align="left"><strong>public void run()</strong> 如果该线程是使用独立的 Runnable 运行对象构造的，则调用该 Runnable 对象的 run 方法；否则，该方法不执行任何操作并返回。</td></tr><tr><td align="left">3</td><td align="left"><strong>public final void setName(String name)</strong> 改变线程名称，使之与参数 name 相同。</td></tr><tr><td align="left">4</td><td align="left"><strong>public final void setPriority(int priority)</strong>  更改线程的优先级。</td></tr><tr><td align="left">5</td><td align="left"><strong>public final void setDaemon(boolean on)</strong> 将该线程标记为守护线程或用户线程。</td></tr><tr><td align="left">6</td><td align="left"><strong>public final void join(long millisec)</strong> 等待该线程终止的时间最长为 millis 毫秒。</td></tr><tr><td align="left">7</td><td align="left"><strong>public void interrupt()</strong> 中断线程。</td></tr><tr><td align="left">8</td><td align="left"><strong>public final boolean isAlive()</strong> 测试线程是否处于活动状态。</td></tr></tbody></table><p>上述方法是被 Thread 对象调用的，下面表格的方法是 Thread 类的静态方法。</p><table><thead><tr><th align="left"><strong>序号</strong></th><th align="left"><strong>方法描述</strong></th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>public static void yield()</strong> 暂停当前正在执行的线程对象，并执行其他线程。</td></tr><tr><td align="left">2</td><td align="left"><strong>public static void sleep(long millisec)</strong> 在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。</td></tr><tr><td align="left">3</td><td align="left"><strong>public static boolean holdsLock(Object x)</strong> 当且仅当当前线程在指定的对象上保持监视器锁时，才返回 true。</td></tr><tr><td align="left">4</td><td align="left"><strong>public static Thread currentThread()</strong> 返回对当前正在执行的线程对象的引用。</td></tr><tr><td align="left">5</td><td align="left"><strong>public static void dumpStack()</strong> 将当前线程的堆栈跟踪打印至标准错误流。</td></tr></tbody></table><h5 id="1-5-4-3-线程安全的实现方法"><a href="#1-5-4-3-线程安全的实现方法" class="headerlink" title="1.5.4.3 线程安全的实现方法"></a>1.5.4.3 线程安全的实现方法</h5><ol><li><p>数据不可变</p><p> 在Java当中，一切不可变的对象（immutable） 一定是线程安全的，无论是对象的方法实现还是方法的调用者。</p></li><li><p>互斥同步</p><p> 互斥同步是常见的一种正确性的保障手段，同步是指在多个线程并发访问共享数据，保证共享数据在同一时刻被同一线程使用。</p></li><li><p>非阻塞同步</p><p> 互斥同步面临的主要问题是，进行线程阻塞和唤醒带来的性能开销，因此这种同步也被称为阻塞同步，从解决问题的方式上来看互斥同步是一种【悲观的并发策略】，其总是认为，只要不去做正确的同步措施，那就肯定会出现问题，无论共享的数据是否真的出现，都会进行加锁。这<br> 将会导致用户态到内核态的转化、维护锁计数器和检查是否被阻塞的线程需要被唤醒等等开销。<br>     随看硬件指令级的发展，我们已经有了另外的选择，基于冲突检的乐观并发策略。通俗的说，就是不管有没有风险，先进行操作，如果没有其他线程征用共享数据，那就直接成功，如果共享数据确实被征用产生了冲突，就再进行补偿策略，常见的补偿策略就是不折的重试，直到<br> 出现设有竞争的共享数据为止，这种乐观并发策略的实现，不再需要把线程阻塞挂起，因此同步操作也被称为非阻塞同步，这种措施的代码也常常被称之为【无锁编程】。</p></li><li><p>无同步方案</p><p> ​在我们这个工作当中，还经常遇到这样一种情况，多个线程需要共享数据，但是这些数据又可以再单独的线程当中计算，得出结果，而不被其他的线程所影响，如果能保证这一点，我们就可以把共享数据的可见范国限制在一个线程之内，这样就无需同步，也能够保证个个线程之间不出现数据征用的问题，说人话就是数据拿过来，我用我的，你用你的，从而保证线程安全，比如说咱们的ThreadLocal。,<br> ​ThreadLoca提供了线程内存储变量的能力，这些变量不同之处在于每一个线程读取的变量是对应的互相独立的。通过ge和set方法就，可以得到当前线程对应的值。</p></li></ol><h3 id="1-5-5锁机制"><a href="#1-5-5锁机制" class="headerlink" title="1.5.5锁机制"></a>1.5.5锁机制</h3><h4 id="1-5-5-1-synchronized简介"><a href="#1-5-5-1-synchronized简介" class="headerlink" title="1.5.5.1 synchronized简介"></a>1.5.5.1 synchronized简介</h4><p>​在多线程并发编程中synchronized一直是元老级角色，很多人都会称呼它为重呈级锁。但是，随看Java SE 1.6对synchronized进行了各种优化之后，有些情况下它就并不那么重，JavaSE1.6中为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁。<br>synchronized有三种方式来加锁，分别是</p><ul><li>修饰实例方法，作用于当前实例加锁，进入同步代码前要获得当前实例的锁</li><li>静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁</li><li>修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ydl.thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">lock</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">ray</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;word&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                say();</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-5-5-2-死锁"><a href="#1-5-5-2-死锁" class="headerlink" title="1.5.5.2 死锁"></a>1.5.5.2 死锁</h4><p>锁升级中涉及的四把锁：</p><ul><li><p>无锁：不加锁</p></li><li><p>偏向锁：不加锁，只有一个线程争夺时，偏心某一个线程，这个线程来了不加锁。</p></li><li><p>轻量级锁：少量量线程来了之后，先尝试自旋，不挂起线程</p><p>  注：挂起线程和恢复线程的操作都需要转入内核态中完成这些操作，给系统的并发性带来很大的压力。在许多应用上共享数据的锁定状态<br>  只会持续很短的一段时间，为了这段时间去挂机和恢复现场并不值得，我们就可以让后边请求的线程稍等一下，不要放弃处理器的执行时<br>  间，看看持有锁的线程是否很快就会释放，锁为了让线程等待，我们只需要让线程执行一个言循环也就是我们说的自旋，这项技术就是所调<br>  的【自旋锁】</p></li><li><p>重量级锁：排队挂起线程</p><p> 死锁</p></li></ul><p>​死锁是这样一种情形：多个线程同时被阻塞，它们中的一个或者全部部在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能<br>正常终止。<br>java死锁产生的四个必要条件：</p><ul><li>互斥使用，即当资源被一个线程使用（占有）时，别的线程不能使用</li><li>不可抢占，资源清求者不能强制从资源占有者手中夺取资源，资源只能由资源占有者主动释放。</li><li>请求和保持，即当资源请求者在请求其他的资源的同时保持对原有资源的占有。</li><li>循环等待，即存在一个等待队列：P1占有P2的资源，P2占有P3的资源，P3占有P1的资源。这样就形成了一个等待环路。</li></ul><p>​当上述四个条件都成立的时候，便形成死锁。当然，死锁的情况下如果打破上述任何一个条件，便可让死锁消失。下面用java代码来模拟一下死锁的产生。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ydl.thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLock</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">final</span> Object MONITOR1= <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">final</span> Object MONITOR2= <span class="string">&quot;12345&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (MONITOR1) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;获取一号锁&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (MONITOR2) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;获取二号锁&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;thread1&quot;</span>).start();  <span class="comment">//开启线程</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (MONITOR2) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;获取二号锁&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (MONITOR1) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;获取一号锁&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;thread1&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/12/29/BkiDUHdlQM25C9R.png" alt="image-20221208113445732"></p><p> wait和notify 等待和唤醒</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ydl.thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object MONITOR= <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (MONITOR) &#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;线程1开始&quot;</span>);</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   MONITOR.wait();</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">               System.out.println(<span class="string">&quot;线程1结束 &quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (MONITOR) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程2开始&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">200</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                MONITOR.notify();</span><br><span class="line">                System.out.println(<span class="string">&quot;线程2结束&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-5-5-3-lock"><a href="#1-5-5-3-lock" class="headerlink" title="1.5.5.3 lock"></a>1.5.5.3 lock</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ydl.thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sun.rmi.runtime.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">lock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">ray</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;word&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    say();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-5-4-线程池"><a href="#1-5-4-线程池" class="headerlink" title="1.5.4 线程池"></a>1.5.4 线程池</h4><p>Java通过Executors提供四种线程池，分别为：</p><ol><li>newCachedThreadPoo1创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</li><li>newFixedThreadPoo1创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</li><li>newScheduledThreadPool创建一个定长线程池，支持定时及周期性任务执行。</li><li>newsing1 eThreadExecutor创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序执行。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ydl.thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pool</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span>() -&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;__________&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;<span class="number">500</span> ; i++) &#123;</span><br><span class="line">            executorService.submit(task); <span class="comment">//提交任务</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java简介</title>
      <link href="/2023/01/17/java/Java%E7%AE%80%E4%BB%8B/"/>
      <url>/2023/01/17/java/Java%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="1-1-Java-简介"><a href="#1-1-Java-简介" class="headerlink" title="1.1 Java 简介"></a>1.1 Java 简介</h3><p>Java 是由 Sun Microsystems 公司于 1995 年 5 月推出的 Java 面向对象程序设计语言和 Java 平台的总称。由  James Gosling和同事们共同研发，并在 1995 年正式推出。</p><p>后来 Sun 公司被 Oracle （甲骨文）公司收购，Java 也随之成为 Oracle 公司的产品。</p><p>Java分为三个体系：</p><ul><li>JavaSE（J2SE）（Java2 Platform Standard Edition，java平台标准版）</li><li>JavaEE(J2EE)(Java 2 Platform,Enterprise Edition，java平台企业版)</li><li>JavaME(J2ME)(Java 2 Platform Micro Edition，java平台微型版)。</li></ul><h3 id="1-2主要特性"><a href="#1-2主要特性" class="headerlink" title="1.2主要特性"></a><strong>1.2主要特性</strong></h3><ul><li>Java 语言是简单的：</li></ul><p>Java 语言的语法与 C 语言和 C++ 语言很接近，使得大多数程序员很容易学习和使用。另一方面，Java 丢弃了 C++ 中很少使用的、很难理解的、令人迷惑的那些特性，如操作符重载、多继承、自动的强制类型转换。特别地，Java 语言不使用指针，而是引用。并提供了自动分配和回收内存空间，使得程序员不必为内存管理而担忧。</p><ul><li>Java 语言是面向对象的：</li></ul><p>Java 语言提供类、接口和继承等面向对象的特性，为了简单起见，只支持类之间的单继承，但支持接口之间的多继承，并支持类与接口之间的实现机制（关键字为 implements）。Java 语言全面支持动态绑定，而 C++语言只对虚函数使用动态绑定。总之，Java语言是一个纯的面向对象程序设计语言。</p><ul><li>Java语言是分布式的：</li></ul><p>Java 语言支持 Internet 应用的开发，在基本的 Java 应用编程接口中有一个网络应用编程接口（java net），它提供了用于网络应用编程的类库，包括 URL、URLConnection、Socket、ServerSocket 等。Java 的 RMI（远程方法激活）机制也是开发分布式应用的重要手段。</p><ul><li>Java 语言是健壮的：</li></ul><p>Java 的强类型机制、异常处理、垃圾的自动收集等是 Java 程序健壮性的重要保证。对指针的丢弃是 Java 的明智选择。Java 的安全检查机制使得 Java 更具健壮性。</p><ul><li>Java语言是安全的：</li></ul><p>Java通常被用在网络环境中，为此，Java 提供了一个安全机制以防恶意代码的攻击。除了Java 语言具有的许多安全特性以外，Java 对通过网络下载的类具有一个安全防范机制（类 ClassLoader），如分配不同的名字空间以防替代本地的同名类、字节代码检查，并提供安全管理机制（类 SecurityManager）让 Java 应用设置安全哨兵。</p><ul><li>Java 语言是体系结构中立的</li></ul><p>Java 程序（后缀为 java 的文件）在 Java 平台上被编译为体系结构中立的字节码格式（后缀为 class 的文件），然后可以在实现这个 Java 平台的任何系统中运行。这种途径适合于异构的网络环境和软件的分发。</p><ul><li>Java 语言是可移植的：</li></ul><p>这种可移植性来源于体系结构中立性，另外，Java 还严格规定了各个基本数据类型的长度。Java  系统本身也具有很强的可移植性，Java 编译器是用 Java 实现的，Java 的运行环境是用 ANSI C 实现的。</p><ul><li>Java 语言是解释型的：</li></ul><p>如前所述，Java 程序在 Java 平台上被编译为字节码格式，然后可以在实现这个 Java 平台的任何系统中运行。在运行时，Java 平台中的 Java 解释器对这些字节码进行解释执行，执行过程中需要的类在联接阶段被载入到运行环境中。</p><ul><li>Java 是高性能的：</li></ul><p>与那些解释型的高级脚本语言相比，Java 的确是高性能的。事实上，Java 的运行速度随着 JIT(Just-In-Time）编译器技术的发展越来越接近于 C++。</p><ul><li>Java 语言是多线程的：</li></ul><p>在 Java 语言中，线程是一种特殊的对象，它必须由 Thread 类或其子（孙）类来创建。通常有两种方法来创建线程：其一，使用型构为 Thread(Runnable) 的构造子类将一个实现了 Runnable 接口的对象包装成一个线程，其二，从 Thread 类派生出子类并重写 run 方法，使用该子类创建的对象即为线程。值得注意的是 Thread 类已经实现了 Runnable 接口，因此，任何一个线程均有它的 run 方法，而 run 方法中包含了线程所要运行的代码。线程的活动由一组方法来控制。Java 语言支持多个线程的同时执行，并提供多线程之间的同步机制（关键字为 synchronized）。</p><ul><li>Java 语言是动态的：</li></ul><p>Java 语言的设计目标之一是适应于动态变化的环境。Java 程序需要的类能够动态地被载入到运行环境，也可以通过网络来载入所需要的类。这也有利于软件的升级。另外，Java 中的类有一个运行时刻的表示，能进行运行时刻的类型检查。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
